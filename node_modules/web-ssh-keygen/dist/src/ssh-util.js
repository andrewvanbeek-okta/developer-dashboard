"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base64url_1 = require("./base64url");
function arrayToString(a) {
    return String.fromCharCode.apply(null, a);
}
exports.arrayToString = arrayToString;
function stringToArray(s) {
    return s.split("").map(c => c.charCodeAt(0));
}
exports.stringToArray = stringToArray;
function base64urlToArray(s) {
    return stringToArray(base64url_1.base64urlDecode(s));
}
exports.base64urlToArray = base64urlToArray;
function pemToArray(pem) {
    return stringToArray(window.atob(pem));
}
exports.pemToArray = pemToArray;
function arrayToPem(a) {
    return window.btoa(a.map(c => String.fromCharCode(c)).join(""));
}
exports.arrayToPem = arrayToPem;
function arrayToLen(a) {
    let result = 0;
    for (let i = 0; i < a.length; i += 1) {
        result = result * 256 + a[i];
    }
    return result;
}
exports.arrayToLen = arrayToLen;
function integerToOctet(n) {
    const result = [];
    for (let i = n; i > 0; i >>= 8) {
        result.push(i & 0xff);
    }
    return result.reverse();
}
exports.integerToOctet = integerToOctet;
function lenToArray(n) {
    const oct = integerToOctet(n);
    let i;
    for (i = oct.length; i < 4; i += 1) {
        oct.unshift(0);
    }
    return oct;
}
exports.lenToArray = lenToArray;
function decodePublicKey(s) {
    const split = s.split(" ");
    const prefix = split[0];
    if (prefix !== "ssh-rsa") {
        throw new Error(`Unknown prefix: ${prefix}`);
    }
    const buffer = pemToArray(split[1]);
    const nameLen = arrayToLen(buffer.splice(0, 4));
    const type = arrayToString(buffer.splice(0, nameLen));
    if (type !== "ssh-rsa") {
        throw new Error(`Unknown key type: ${type}`);
    }
    const exponentLen = arrayToLen(buffer.splice(0, 4));
    const exponent = buffer.splice(0, exponentLen);
    const keyLen = arrayToLen(buffer.splice(0, 4));
    const key = buffer.splice(0, keyLen);
    return { type, exponent, key, name: split[2] };
}
exports.decodePublicKey = decodePublicKey;
function checkHighestBit(v) {
    if (v[0] >> 7 === 1) {
        return [0, ...v];
    }
    return v;
}
exports.checkHighestBit = checkHighestBit;
function jwkToInternal(jwk) {
    return {
        type: "ssh-rsa",
        exponent: checkHighestBit(stringToArray(base64url_1.base64urlDecode(jwk.e))),
        name: "name",
        key: checkHighestBit(stringToArray(base64url_1.base64urlDecode(jwk.n))),
    };
}
function encodePublicKey(jwk, name) {
    const k = jwkToInternal(jwk);
    k.name = name;
    const keyLenA = lenToArray(k.key.length);
    const exponentLenA = lenToArray(k.exponent.length);
    const typeLenA = lenToArray(k.type.length);
    const array = [
        ...typeLenA, ...stringToArray(k.type), ...exponentLenA, ...k.exponent, ...keyLenA, ...k.key,
    ];
    const encoding = arrayToPem(array);
    return `${k.type} ${encoding} ${k.name}`;
}
exports.encodePublicKey = encodePublicKey;
function asnEncodeLen(n) {
    let result = [];
    if (n >> 7) {
        result = integerToOctet(n);
        result.unshift(0x80 + result.length);
    }
    else {
        result.push(n);
    }
    return result;
}
exports.asnEncodeLen = asnEncodeLen;
function encodePrivateKey(jwk) {
    const order = ["n", "e", "d", "p", "q", "dp", "dq", "qi"];
    const list = order.map(prop => {
        const v = checkHighestBit(stringToArray(base64url_1.base64urlDecode(jwk[prop])));
        const len = asnEncodeLen(v.length);
        return [0x02].concat(len, v);
    });
    let seq = [0x02, 0x01, 0x00];
    seq = seq.concat(...list);
    const len = asnEncodeLen(seq.length);
    const a = [0x30].concat(len, seq);
    return arrayToPem(a);
}
exports.encodePrivateKey = encodePrivateKey;
//# sourceMappingURL=ssh-util.js.map